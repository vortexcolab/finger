console.log("Entraste no main.js ");
// The ID of the extension we want to talk to.
const extensionId = "kokppcfcdcfefgilagbhibfakijlpcfo";

let videoTrack, audioTrack, trackAudioProxy, trackVideoProxy;

// Create a function to dispatch custom events
function dispatchEnabledChangeEvent(track, enabled) {
  const event = new Event('enabledchange');
  event.enabled = enabled;
  track.dispatchEvent(event);
}

// Capture function calls
function interceptUserMedia() {

  // Save the original getUserMedia method
  const originalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

  // Override getUserMedia method
  navigator.mediaDevices.getUserMedia = async function(constraints) {
    console.log('Custom code executed in getUserMedia');

    // Call the original getUserMedia method with the provided constraints
    return originalGetUserMedia.call(navigator.mediaDevices, constraints).then(async function(stream) {
      console.log('Custom handling of MediaStream:', stream);

      // Get video and audio tracks
      videoTrack = stream.getVideoTracks()[0];
      audioTrack = stream.getAudioTracks()[0];

      if (videoTrack && audioTrack)
        chrome.runtime.sendMessage(extensionId, { action: 'navigator.mediaDevices.getUserMedia', data: {audio: {muted: audioTrack.muted, enabled: audioTrack.enabled}, video: {muted: videoTrack.muted, enabled: videoTrack.enabled}} });
      else if (videoTrack)
        chrome.runtime.sendMessage(extensionId, { action: 'navigator.mediaDevices.getUserMedia', data: {audio: null, video: {muted: videoTrack.muted, enabled: videoTrack.enabled}} });
      else if (audioTrack)
        chrome.runtime.sendMessage(extensionId, { action: 'navigator.mediaDevices.getUserMedia', data: {audio: {muted: audioTrack.muted, enabled: audioTrack.enabled}, video: null} });


      // Define setter for enabled property on videoTrack and audioTrack
      Object.defineProperty(videoTrack, 'enabled', {
        set: function(value) {
          if (this.enabled !== value) {
            dispatchEnabledChangeEvent(this, value);
          }
          this._enabled = value;
        },
        get: function() {
          return this._enabled;
        }
      });

      Object.defineProperty(audioTrack, 'enabled', {
        set: function(value) {
          if (this.enabled !== value) {
            dispatchEnabledChangeEvent(this, value);
          }
          this._enabled = value;
        },
        get: function() {
          return this._enabled;
        }
      });

      // Add event listener for custom 'enabledchange' event
      videoTrack.addEventListener('enabledchange', function(event) {
        console.log(`Video Enabled state changed to: ${event.enabled}`);
        if (event.enabled)
          chrome.runtime.sendMessage(extensionId, { action: 'camera', data: 'enabled'});
        else
          chrome.runtime.sendMessage(extensionId, { action: 'camera', data: 'disabled'});   
      });
      audioTrack.addEventListener('enabledchange', function(event) {
        console.log(`Audio Enabled state changed to: ${event.enabled}`);
        if (event.enabled)
          chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'enabled'});
        else
          chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'disabled'});        
      });

      // Add event listeners for video track
      videoTrack.onmute = function(event) {
        console.log("Camera muted.");
        chrome.runtime.sendMessage(extensionId, { action: 'camera', data: 'muted' });
      };
      videoTrack.onunmute = function(event) {
        console.log("Camera unmuted.");
        chrome.runtime.sendMessage(extensionId, { action: 'camera', data: 'unmuted' });
      };
      videoTrack.onended = function(event) {
        console.log("Camera ended.");
        chrome.runtime.sendMessage(extensionId, { action: 'camera', data: 'ended' });
      };

      // Add event listeners for audio track
      audioTrack.onmute = function(event) {
        console.log("Audio muted.");
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'muted' });
      };
      audioTrack.onunmute = function(event) {
        console.log("Audio unmuted.");
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'unmuted' });
      };
      audioTrack.onended = function(event) {
        console.log("Audio ended.");
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'ended' });
      };

      console.log('Custom handling of MediaStream:', videoTrack);
      return stream;
    })
    .catch(function(error) {
      console.error('Error accessing the camera:', error);
      throw error;
    });
  };    
}

function interceptCanvasFingerprint() {

  /*
    CANVAS CONTEXT

    document.createElement('canvas')
    document.getElementsByTagName('canva')
    HTMLCanvasElement.getContext(..)
    HTMLCanvasElement.toDataURL
    CanvasRenderingContext2D.rect(..)
    CanvasRenderingContext2D.isPointInPath(..)
    HTMLCanvasElement.width
    HTMLCanvasElement.height
    CanvasRenderingContext2D.textBaseline
    CanvasRenderingContext2D.fillStyle
    CanvasRenderingContext2D.fillRect
    CanvasRenderingContext2D.font
    CanvasRenderingContext2D.fillText
    CanvasRenderingContext2D.globalCompositeOperation
    CanvasRenderingContext2D.beginPath()
    CanvasRenderingContext2D.arc()
    CanvasRenderingContext2D.closePath()
    CanvasRenderingContext2D.fill()
  */

  const originalCreateElement = document.createElement;
  document.createElement = function(elem) {
    if (elem === "canvas") {
      chrome.runtime.sendMessage(extensionId, { action: 'canvas', data: 'document.createElement' });
    }
    return originalCreateElement.call(document, elem);
  };

  const originalGetElementsByTagName = document.getElementsByTagName;
  document.getElementsByTagName = function(elem) {
    if (elem === "canvas") {
      chrome.runtime.sendMessage(extensionId, { action: 'canvas', data: 'document.getElementsByTagName' });
    }
    return originalGetElementsByTagName.call(document, elem);
  };


  const originalGetContext = HTMLCanvasElement.prototype.getContext;
  HTMLCanvasElement.prototype.getContext = function(contextType, ...args) {
    chrome.runtime.sendMessage(extensionId, { action: 'canvas', data: 'HTMLCanvasElement.getContext' });
    const context = originalGetContext.apply(this, [contextType, ...args]);
    return context;
  };


  const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
  HTMLCanvasElement.prototype.toDataURL = function(type, quality) {
    chrome.runtime.sendMessage(extensionId, { action: 'canvas', data: 'HTMLCanvasElement.toDataURL' });
    const dataURL = originalToDataURL.apply(this, arguments);
    return dataURL;
  };

}

function interceptScreenFingerprint() {

  /*

    JavaScript

    screen resolution

  */

  /*
  Intercepting reads of screen properties can be quite challenging because JavaScript does not provide direct hooks or interception mechanisms 
  for property reads. However, you can achieve this by using a technique called property getters.
  In JavaScript, you can define a special kind of method called a getter that is invoked when a specific property is accessed.
  By defining getters for screen properties, you can intercept and log any reads of those properties.
  */

  // Salvar os valores originais das propriedades da tela
  const originalScreenWidth = window.screen.width;
  const originalScreenHeight = window.screen.height;

  // Substituir os getters para a largura e altura da tela
  Object.defineProperty(window.screen, 'width', {
    get: function() {
      // Registrar o acesso à largura da tela
      console.log('Acesso à largura da tela interceptado');
      // Enviar mensagem
      chrome.runtime.sendMessage(extensionId, { action: 'screen', data: 'width' });
      // Retornar o valor original
      return originalScreenWidth;
    }
  });

  Object.defineProperty(window.screen, 'height', {
    get: function() {
      // Registrar o acesso à altura da tela
      console.log('Acesso à altura da tela interceptado');
      // Enviar mensagem
      chrome.runtime.sendMessage(extensionId, { action: 'screen', data: 'height' });
      // Retornar o valor original
      return originalScreenHeight;
    }
  });


}

function interceptTimezoneFingerprint() {

  /*

    JavaScript

    timezone

  */

  // Save the original getTimezoneOffset method
  const originalGetTimezoneOffset = Date.prototype.getTimezoneOffset;

  // Override the getTimezoneOffset method
  Date.prototype.getTimezoneOffset = function() {
    // Log the access to getTimezoneOffset
    console.log('Access to Date.prototype.getTimezoneOffset intercepted');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'timezone', data: '1' });
    // Call the original method and return its result
    return originalGetTimezoneOffset.call(this);
  };


}

function interceptHardwareConcurrency() {
  // Salvar o valor original de Navigator.hardwareConcurrency
  const originalHardwareConcurrency = navigator.hardwareConcurrency;

  // Substituir o getter para Navigator.hardwareConcurrency
  Object.defineProperty(navigator, 'hardwareConcurrency', {
    get: function() {
      // Registrar o acesso ao hardwareConcurrency
      console.log('Acesso a Navigator.hardwareConcurrency interceptado');
      // Enviar mensagem
      chrome.runtime.sendMessage(extensionId, { action: 'hardwareConcurrency', data: '1' });
      // Retornar o valor original
      return originalHardwareConcurrency;
    }
  });


}

function interceptMaxTouchPoints() {
  // Salvar o valor original de navigator.maxTouchPoints
  const originalMaxTouchPoints = navigator.maxTouchPoints;

  // Substituir o getter para navigator.maxTouchPoints
  Object.defineProperty(navigator, 'maxTouchPoints', {
    get: function() {
      // Registrar o acesso a maxTouchPoints
      console.log('Acesso a navigator.maxTouchPoints interceptado');
      // Enviar mensagem
      chrome.runtime.sendMessage(extensionId, { action: 'maxTouchPoints', data: '1' });
      // Retornar o valor original
      return originalMaxTouchPoints;
    }
  });
}

function interceptPluginEnumerationFingerprint() {
  /*
    
    JavaScript

    browser plugins
    plugin version
    mime types
    system fonts (via CSS introspection)
    everycookies
    Check NON-Script List

  */
}

function interceptAudioFingerprint() {

  /*

    AUDIO CONTEXT

    window.OfflineAudioContext()
    window.webkitOfflineAudioContext()
    AudioContextObject.createOscillator()
    oscillatorNodeObject.type
    oscillatorNodeObject.frequency.value
    dynamicCompressorNodeObject.createDynamicsCompressor()
    dynamicCompressorNodeObject.threshold
    dynamicCompressorNodeObject.threshold.value
    dynamicCompressorNodeObject.knee
    dynamicCompressorNodeObject.knee.value
    dynamicCompressorNodeObject.ratio
    dynamicCompressorNodeObject.ratio.value
    dynamicCompressorNodeObject.reduction
    dynamicCompressorNodeObject.reduction.value
    dynamicCompressorNodeObject.attack
    dynamicCompressorNodeObject.attack.value
    dynamicCompressorNodeObject.release
    dynamicCompressorNodeObject.release.value
    oscillatorNodeObject.connect(dynamicCompressorNodeObject)
    dynamicCompressorNodeObject.connect(..)
    AudioContextObject.destination
    oscillatorNodeObject.start(..)
    AudioContextObject.startRendering(..)
    AudioContextObject.oncomplete(..)

  */

  // Salva uma referência ao construtor original de AudioContext
  const OriginalAudioContext = window.AudioContext || window.webkitAudioContext;
  // Substitui o construtor AudioContext
  window.AudioContext = function() {
    // Cria uma nova instância do AudioContext
    const audioContext = new OriginalAudioContext();
    // Log do uso do AudioContext
    console.log('AudioContext foi criado');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'new AudioContext' });
    // Retorna a nova instância do AudioContext
    return audioContext;
  };

  // Salva uma referência ao construtor original de OfflineAudioContext
  const OriginalOfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
  // Substitui o construtor OfflineAudioContext
  window.OfflineAudioContext = function(numberOfChannels, length, sampleRate) {
    // Cria uma nova instância do OfflineAudioContext
    const offlineAudioContext = new OriginalOfflineAudioContext(numberOfChannels, length, sampleRate);
    // Log do uso do OfflineAudioContext
    console.log('OfflineAudioContext foi criado');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'window.OfflineAudioContext' });
    // Retorna a nova instância do OfflineAudioContext
    return offlineAudioContext;
  };

  // Save a reference to the original createOscillator method
  const originalCreateOscillator = BaseAudioContext.prototype.createOscillator;
  // Override the createOscillator method
  BaseAudioContext.prototype.createOscillator = function() {
    // Log the usage of createOscillator
    console.log('BaseAudioContext.createOscillator() was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'BaseAudioContext.createOscillator' });
    // Call the original method and return its result
    return originalCreateOscillator.apply(this, arguments);
  };

// Salvar uma referência aos métodos getter originais
const originalTypeGetter = Object.getOwnPropertyDescriptor(OscillatorNode.prototype, 'type').get;
const originalFrequencyGetter = Object.getOwnPropertyDescriptor(AudioParam.prototype, 'value').get;

// Substituir o método getter para oscillatorNodeObject.type
Object.defineProperty(OscillatorNode.prototype, 'type', {
  get: function() {
    // Registrar o acesso a oscillatorNodeObject.type
    console.log('Acesso a oscillatorNodeObject.type interceptado');
    // Enviar mensagem
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'oscillatorNodeObject.type' });
    // Retornar o valor original
    return originalTypeGetter.call(this);
  }
});

// Substituir o método getter para oscillatorNodeObject.frequency.value
Object.defineProperty(AudioParam.prototype, 'value', {
  get: function() {
    // Registrar o acesso a oscillatorNodeObject.frequency.value
    console.log('Acesso a oscillatorNodeObject.frequency.value interceptado');
    // Enviar mensagem
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'oscillatorNodeObject.frequency.value' });
    // Retornar o valor original
    return originalFrequencyGetter.call(this);
  }
});

  // Save a reference to the original createDynamicsCompressor method
  const originalCreateDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
  // Override the createDynamicsCompressor method
  AudioContext.prototype.createDynamicsCompressor = function() {
    // Log the creation of a DynamicsCompressorNode object
    console.log('DynamicsCompressorNode object was created');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'new DynamicsCompressorNode' });
    // Call the original method and return its result
    return originalCreateDynamicsCompressor.apply(this, arguments);
  };

  // Save a reference to the original constructor of DynamicsCompressorNode
  const OriginalDynamicsCompressorNode = window.DynamicsCompressorNode;
  // Override the constructor of DynamicsCompressorNode
  window.DynamicsCompressorNode = function() {
    // Create a new instance of DynamicsCompressorNode
    const dynamicsCompressorNode = new OriginalDynamicsCompressorNode();
    // Define setter methods for the properties you want to monitor
    Object.defineProperty(dynamicsCompressorNode.threshold, 'value', {
      set: function(newValue) {
        // Log the change to threshold value
        console.log('Threshold value changed to:', newValue);
        // send message
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'DynamicsCompressorNode.threshold.value' });
        // Set the new value
        dynamicsCompressorNode.threshold.setValueAtTime(newValue, this.context.currentTime);
      }
    });

    Object.defineProperty(dynamicsCompressorNode.knee, 'value', {
      set: function(newValue) {
        // Log the change to knee value
        console.log('Knee value changed to:', newValue);
        // send message
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'DynamicsCompressorNode.knee.value' });
        // Set the new value
        dynamicsCompressorNode.knee.setValueAtTime(newValue, this.context.currentTime);
      }
    });

    Object.defineProperty(dynamicsCompressorNode.ratio, 'value', {
      set: function(newValue) {
        // Log the change to ratio value
        console.log('Ratio value changed to:', newValue);
        // send message
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'DynamicsCompressorNode.ratio.value' });
        // Set the new value
        dynamicsCompressorNode.ratio.setValueAtTime(newValue, this.context.currentTime);
      }
    });

    Object.defineProperty(dynamicsCompressorNode.reduction, 'value', {
      set: function(newValue) {
        // Log the change to reduction value
        console.log('Reduction value changed to:', newValue);
        // send message
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'DynamicsCompressorNode.reduction.value' });
        // Set the new value
        dynamicsCompressorNode.reduction.setValueAtTime(newValue, this.context.currentTime);
      }
    });

    Object.defineProperty(dynamicsCompressorNode.attack, 'value', {
      set: function(newValue) {
        // Log the change to attack value
        console.log('Attack value changed to:', newValue);
        // send message
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'DynamicsCompressorNode.attack.value' });
        // Set the new value
        dynamicsCompressorNode.attack.setValueAtTime(newValue, this.context.currentTime);
      }
    });

    Object.defineProperty(dynamicsCompressorNode.release, 'value', {
      set: function(newValue) {
        // Log the change to release value
        console.log('Release value changed to:', newValue);
        // send message
        chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'DynamicsCompressorNode.release.value' });
        // Set the new value
        dynamicsCompressorNode.release.setValueAtTime(newValue, this.context.currentTime);
      }
    });

    // Return the new instance of DynamicsCompressorNode
    return dynamicsCompressorNode;
  };

  // Save a reference to the original connect method
  const originalConnect = OscillatorNode.prototype.connect;

  // Override the connect method
  OscillatorNode.prototype.connect = function(destination, output, input) {
    // Log the usage of connect
    console.log('OscillatorNode.connect() was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'OscillatorNode.connect' });
    // Call the original method with the provided arguments
    return originalConnect.call(this, destination, output, input);
  };

  // Save a reference to the original connect method
  const originalDynamicsCompressorConnect = DynamicsCompressorNode.prototype.connect;
  // Override the connect method
  DynamicsCompressorNode.prototype.connect = function(destination, output, input) {
    // Log the usage of connect
    console.log('DynamicsCompressorNode.connect() was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'DynamicsCompressorNode.connect' });
    // Call the original method with the provided arguments
    return originalDynamicsCompressorConnect.call(this, destination, output, input);
  };

  // Save the original destination property
  const originalDestination = AudioContext.prototype.destination;
  // Override the destination property with a custom one
  Object.defineProperty(AudioContext.prototype, 'destination', {
    get: function() {
      // Log the access to destination
      console.log('Access to AudioContext.destination intercepted');
      // Send message
      chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'AudioContext.destination' });
      // Return the original destination
      return originalDestination;
    }
  });

  // Save a reference to the original start method of OscillatorNode
  const originalStart = OscillatorNode.prototype.start;
  // Override the start method of OscillatorNode
  OscillatorNode.prototype.start = function() {
    // Log the usage of start
    console.log('OscillatorNode.start() was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'OscillatorNode.start' });
    // Call the original method with the provided arguments
    return originalStart.apply(this, arguments);
  };

  // Save a reference to the original startRendering method of AudioContext
  const originalStartRendering = AudioContext.prototype.startRendering;
  // Override the startRendering method of AudioContext
  AudioContext.prototype.startRendering = function() {
    // Log the usage of startRendering
    console.log('AudioContext.startRendering() was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'AudioContext.startRendering()' });
    // Call the original method with the provided arguments
    return originalStartRendering.apply(this, arguments);
  };

  // Save a reference to the original oncomplete method of AudioContext
  const originalOnComplete = AudioContext.prototype.oncomplete;

  // Override the oncomplete method of AudioContext
  AudioContext.prototype.oncomplete = function() {
    // Log the usage of oncomplete
    console.log('AudioContext.oncomplete() was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'audio', data: 'AudioContext.oncomplete()' });
    // Call the original method with the provided arguments
    return originalOnComplete.apply(this, arguments);
  };

}

function interceptFontEnumerationFingerprint() {
  /*

    Font Enumeration
    # based on: https://github.com/fingerprintjs/fingerprintjs/blob/master/src/sources/fonts.ts#L123

    Detect more than 10 hits in the follow procedure

    HTMLElement.style.position
    HTMLElement.style.top
    HTMLElement.style.left
    HTMLElement.style.fontFamily
    HTMLElement.style.textContent

  */

  // Save the original setter methods for style properties
  const originalSetPosition = Object.getOwnPropertyDescriptor(HTMLElement.prototype.style, 'position').set;
  const originalSetTop = Object.getOwnPropertyDescriptor(HTMLElement.prototype.style, 'top').set;
  const originalSetLeft = Object.getOwnPropertyDescriptor(HTMLElement.prototype.style, 'left').set;
  const originalSetFontFamily = Object.getOwnPropertyDescriptor(HTMLElement.prototype.style, 'fontFamily').set;
  const originalSetTextContent = Object.getOwnPropertyDescriptor(HTMLElement.prototype.style, 'textContent').set;

  // Override the setters for style properties
  Object.defineProperty(HTMLElement.prototype.style, 'position', {
    set: function(value) {
      // Log the change to position
      console.log('Change to position intercepted:', value);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'font-enumeration', data: 'position' });
      // Call the original setter method
      originalSetPosition.call(this, value);
    }
  });

  Object.defineProperty(HTMLElement.prototype.style, 'top', {
    set: function(value) {
      // Log the change to top
      console.log('Change to top intercepted:', value);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'font-enumeration', data: 'top' });
      // Call the original setter method
      originalSetTop.call(this, value);
    }
  });

  Object.defineProperty(HTMLElement.prototype.style, 'left', {
    set: function(value) {
      // Log the change to left
      console.log('Change to left intercepted:', value);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'font-enumeration', data: 'left' });
      // Call the original setter method
      originalSetLeft.call(this, value);
    }
  });

  Object.defineProperty(HTMLElement.prototype.style, 'fontFamily', {
    set: function(value) {
      // Log the change to fontFamily
      console.log('Change to fontFamily intercepted:', value);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'font-enumeration', data: 'fontFamily' });
      // Call the original setter method
      originalSetFontFamily.call(this, value);
    }
  });

  Object.defineProperty(HTMLElement.prototype.style, 'textContent', {
    set: function(value) {
      // Log the change to textContent
      console.log('Change to textContent intercepted:', value);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'font-enumeration', data: 'textContent' });
      // Call the original setter method
      originalSetTextContent.call(this, value);
    }
  });
}

function interceptFontMetrics() {

  /*

    FONT METRICS

    Access to:

    // mandatory
    HTMLELEMENT.fontFamily
    HTMLELEMENT.offsetWidth
    HTMLELEMENT.offsetHeight

  */

  // Save the original setter for the fontFamily property
  const originalFontFamilySetter = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'fontFamily').set;

  // Save the original getters for the offsetWidth and offsetHeight properties
  const originalOffsetWidthGetter = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetWidth').get;
  const originalOffsetHeightGetter = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight').get;

  // Override the setter for fontFamily, and the getters for offsetWidth and offsetHeight
  Object.defineProperty(HTMLElement.prototype, 'fontFamily', {
    set: function(value) {
      // Log the change to fontFamily
      console.log('Change to fontFamily intercepted:', value);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'fontMetrics', data: 'fontFamily' });
      // Call the original setter method
      originalFontFamilySetter.call(this, value);
    }
  });

  Object.defineProperty(HTMLElement.prototype, 'offsetWidth', {
    get: function() {
      // Log the access to offsetWidth
      console.log('Access to offsetWidth intercepted');
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'font-metrics', data: 'offsetWidth' });
      // Return the original value
      return originalOffsetWidthGetter.call(this);
    }
  });

  Object.defineProperty(HTMLElement.prototype, 'offsetHeight', {
    get: function() {
      // Log the access to offsetHeight
      console.log('Access to offsetHeight intercepted');
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'font-metrics', data: 'offsetHeight' });
      // Return the original value
      return originalOffsetHeightGetter.call(this);
    }
  });

}

function interceptCacheFingerprint() {

  /*
    CACHE BASED SIDE-CHANNELS

    // mandatory
    performance.now()


    TypedArrayObject
    TypedArray.from()
    TypedArray.of()
    IntArrayObject
    IntArray8Object
    Uint8ClampedArray
    Int16Array
    Uint16Array
    Int32Array
    Uint32Array
    Float32Array
    Float64Array
    BigInt64Array
    BigUint64Array

  */

  // Save the original performance.now method
  const originalPerformanceNow = performance.now;
  // Override the performance.now method
  performance.now = function() {
    // Log the invocation of performance.now
    console.log('performance.now() was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'cache', data: 'performance.now()' });
    // Call the original method and return its result
    return originalPerformanceNow.apply(performance, arguments);
  };

  // Define a list of TypedArray constructors
  const typedArrayConstructors = [
    TypedArray,
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    BigInt64Array,
    BigUint64Array
  ];

  // Iterate over each TypedArray constructor and intercept its static methods
  typedArrayConstructors.forEach(constructor => {

    // Salva o construtor original
    const originalConstructor = constructor;

    // Substitui o construtor
    window[constructor.name] = function() {
      // Loga a inicialização do TypedArray
      console.log(`${constructor.name} was initialized`);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'cache', data: "new " + constructor.name });
      // Chama o construtor original com os argumentos fornecidos
      return new originalConstructor(...arguments);
    };

  });

}

function interceptAnimationFingerprint() {
  // Salva a função original requestAnimationFrame
  const originalRequestAnimationFrame = window.requestAnimationFrame;

  // Substitui requestAnimationFrame
  window.requestAnimationFrame = function(callback) {
    // Registra a invocação de requestAnimationFrame
    console.log('requestAnimationFrame was called');
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'animation', data: 'window.requestAnimationFrame' });
    // Chama a função original com o callback fornecido
    return originalRequestAnimationFrame(callback);
  };
}

function interceptPluginEnumeration() {

  /*

  Plugin Enumeration

  // at list one
  performance.getEntriesByType("resource")
  addEventListener("message", (event) => {});
  onmessage = (event) => {}
  fetch('chrome-extension://<UUID>/<path>’, { headers });, where <UUID> is the public extension ID, and <path> is the path to the resource.

  */

  // Salva a função original getEntriesByType
  const originalGetEntriesByType = performance.getEntriesByType;
  // Substitui getEntriesByType
  performance.getEntriesByType = function(type) {
    if (type === "resource") {
      // Registra a invocação de getEntriesByType
      console.log(`performance.getEntriesByType("${type}") was called`);
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'plugin-enumeration', data: 'performance.getEntriesByType("resource")' });
    }
    // Chama a função original com o tipo fornecido
    return originalGetEntriesByType.call(performance, type);
  };

  // Salva a referência para o valor atual de window.onmessage
  let originalOnMessage = window.onmessage;
  // Define uma propriedade personalizada para monitorar alterações em window.onmessage
  Object.defineProperty(window, 'onmessage', {
    set: function(value) {
      // Registra a definição de window.onmessage
      console.log('window.onmessage foi definido');
      // send message
      chrome.runtime.sendMessage(extensionId, { action: 'plugin-enumeration', data: 'window.onmessage' });
      // Salva o novo valor atribuído a window.onmessage
      originalOnMessage = value;
    }
  });

  // Salva a referência para a função original fetch
  const originalFetch = window.fetch;
  // Substitui fetch
  window.fetch = function(input, init) {
    // Registra a invocação de fetch
    console.log('fetch was called with:', input, init);
    // send message
    chrome.runtime.sendMessage(extensionId, { action: 'plugin-enumeration', data: 'fetch' });
    // Chama a função original fetch com os argumentos fornecidos
    return originalFetch.apply(this, arguments);
  };

  /*

    ALTERNATIVA

    // Salva a referência para a função original fetch
    const originalFetch = window.fetch;

    // Substitui fetch usando Object.defineProperty
    Object.defineProperty(window, 'fetch', {
      value: function(input, init) {
        // Registra a invocação de fetch
        console.log('fetch was called with:', input, init);
        // Chama a função original fetch com os argumentos fornecidos
        return originalFetch.apply(this, arguments);
      },
      writable: true, // Garante que a propriedade pode ser sobrescrita
      configurable: true // Permite que a propriedade seja modificada posteriormente
    });
  
  */

}


function init() {
  interceptUserMedia();
  interceptCanvasFingerprint();
  interceptScreenFingerprint();
  interceptTimezoneFingerprint();
  interceptHardwareConcurrency();
  interceptMaxTouchPoints();
  interceptPluginEnumerationFingerprint();
  interceptAudioFingerprint();
  interceptFontEnumerationFingerprint();
  interceptFontMetrics();
  interceptCacheFingerprint();
  interceptAnimationFingerprint();
  interceptPluginEnumeration();
}

init();

/*
// Execute getUserMedia with video and audio constraints
const streamPromise = navigator.mediaDevices.getUserMedia({ video: true, audio: true });

// Handle the obtained stream
streamPromise.then(function(stream) {
  const videoElement = document.createElement('video');
  videoElement.srcObject = stream;
  document.body.appendChild(videoElement);
  videoElement.play();
})
.catch(function(error) {
  console.error('Error accessing the camera:', error);
});
*/

/*

HTTP HEADERS

User-Agent
Accept
Cookie
Set-Cookie
HTTP HEADER order
Etag

*/















